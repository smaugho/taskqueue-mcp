---
description: General development workflow using TaskQueue MCP services for managing AIâ€‘assisted, humanâ€‘inâ€‘theâ€‘loop project and task execution, strongly recommending ATDD.
globs:
alwaysApply: true
---

# AIâ€‘Assisted, Humanâ€‘inâ€‘theâ€‘Loop Development Workflow using TaskQueue MCP

## Introduction

- This guide outlines a general development workflow using the TaskQueue MCP (Model Context Protocol) services.
- TaskQueue MCP provides tools for AI agents (like Cursor) to manage projects and tasks in a structured manner, involving human confirmation before programmatic approval.
- **Optional Project Context:** You might adapt this workflow to your specific projectâ€‘planning methodology. For example:
  - A TaskQueue **"Project"** MUST represent **exactly one Job / User Story**.
  - The `initialPrompt` for the Project could be the Job title.
  - The `projectPlan` for the Project **MUST** contain:
    - The full description associated with that Job.
    - A **Mermaid diagram** visualizing the work's core concepts, flows, or changes. (*Consider diagram guidelines like using Mermaid syntax, visualizing relevant aspects, choosing appropriate types, and prioritizing clarity.*)
  - **"Tasks"** would then be the individual actions required to complete that specific Job, following the categoryâ€‘specific workflow defined below.

## Project Tooling

- **Package Management:** All project dependencies MUST be managed using `npm`. Use `npm install [--dev]` to add dependencies and ensure the `package-lock.json` file is committed.
- **Task Runner:** Project tasks (linting, building, testing) are defined in `package.json` scripts and should be run using `npm run <script_name>`.

---

## Job / Project Categories & Default Workflows

Every TaskQueue **Project** represents **exactly** one **Job / User Story**. Depending on the nature of that Job, the internal task list follows a different highâ€‘level flow. The table below summarises the recommended skeleton for each category â€“ later sections reference these names.

| Category                                 | Typical Trigger                                                   | Primary Driver    | Default Task Skeleton                                                                                                                                      |
| ---------------------------------------- | ----------------------------------------------------------------- | ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **New Use Case**                         | Brandâ€‘new behaviour / feature                                     | ATDD â€“ Outsideâ€‘In | 1ï¸âƒ£ Acceptance Test â€“ Red â†’ 2ï¸âƒ£ Plan Review #1 â†’ 3ï¸âƒ£ Component Batch #1 (R/G/R + CommitConfirm) â†’ â€¦ iterate â†’ âœ… Review Documentation + CommitConfirm |
| **Bug / Useâ€‘Case Modification**          | Defect or changed requirement                                     | TDD (Plan First)  | 1ï¸âƒ£ Plan Review #1 â†’ 2ï¸âƒ£ Component Batch #1 (R/G/R + CommitConfirm) â†’ â€¦ iterate â†’ âœ… Review Documentation + CommitConfirm                                   |
| **Domain Rule Change**                   | Businessâ€‘rule evolution                                           | Metaâ€‘coordination | 1ï¸âƒ£ Impact Analysis â†’ spawn child **New Use Case** projects â†’ local removals + CommitConfirm â†’ âœ… Global Verification & Close                               |
| **Internal Workflow / Refactor / Chore** | Techâ€‘debt, infra swap, renaming, style fixes, cleanup, doc/config | Refactor Workflow | 1ï¸âƒ£ Plan Review #1 â†’ 2ï¸âƒ£ Component Batch #1 (Netâœ”/Refâœ‚/VerðŸŸ¢ + CommitConfirm) â†’ â€¦ iterate (acceptance test safeguard) â†’ âœ… Review Documentation + CommitConfirm         |

> **Task Titles & Descriptions** â€“ Always phrase tasks in terms of *observable user value* (e.g. *"CLI lists metrics grouped by project"*). Avoid naming concrete classes or functions unless strictly unavoidable.

---

## Core Development Workflow

1.  **Select Next Project**

    - Use `mcp_taskqueue_list_projects state='open'` to find the first project that is not yet completed. Prioritize working through projects sequentially based on their order in the list or creation time.
    - If no open project exists for the desired workâ€‘stream (e.g., a new feature or Step), create one using `mcp_taskqueue_create_project` or `mcp_taskqueue_generate_project_plan`. **Ensure the initial tasks follow the appropriate Category Workflow skeleton defined below.** Note the `projectId`.
    - **Set the identified **`projectId`** as the current focus.**
    - **Before starting work:** Use `mcp_taskqueue_read_project` with the selected `projectId` and present the full project details (initial prompt, plan, diagram, and task list) to the human developer for context and confirmation to proceed.

2.  **Get Next Task**

    - Use `mcp_taskqueue_get_next_task` with the current `projectId` to retrieve the next available (nonâ€‘approved) task *within that project*.

3.  **Understand the Task**

    - Use `mcp_taskqueue_read_task` with the `projectId` and `taskId` to get full details.
    - **Identify the Project Category** (from `projectPlan` or task structure) and **the specific step within that category's workflow** the task represents (e.g., "Acceptance Test â€“ Red", "Plan Review #1", "Component Batch #1 â€“ Green", "Impact Analysis").
    - Review `toolRecommendations` and `ruleRecommendations` if provided. **For Refactor and Review Documentation tasks, this includes ensuring all relevant quality, style, and pattern rules are considered.**
    - **Consult embedded Category & Reference blocks:** Every task begins with a Category section copy and a reference list. **Read that Category related rule IN FULL, fetching the relevant rule using `fetch_rule`** (it governs exactly how to implement the task). Then **open each referenced code file using the **`read_file`** tool** and **open each web link using the **`web_search`** tool** listed in the reference block:
        - If a referenced file shows an existing or nearâ€‘identical solution, surface this to the human developer to avoid duplication.
        - Use patterns from referenced files or articles to guide your implementation, tests, and naming.
    - Only after reading the Category rules **and** all references should you begin planning the task implementation.**

4.  **Implement the Task (Execute Category Workflow Step)**

    - **Testing Layer Note:** When adding new tests (e.g., in the Red phase of a Component Batch not driven by an acceptance test failure), add the test at the **lowest appropriate layer** (Unit or Integration). Follow the guidance in `testing_strategy.mdc` (prefer state/value verification over collaboration verification).
    - **Taskâ€‘Change Note:** If the task description needs modification *during* implementation, **present the proposed changes to the human developer and wait for explicit confirmation** before calling `mcp_taskqueue_update_task`. The same rule applies to future tasks: always fetch (`mcp_taskqueue_read_task`) then update (`mcp_taskqueue_update_task`) only after confirmation.
    - **Proceed according to the Project Category and task type:**

### Category: New Use Case

Refer to the rule `dev_new_use_case.mdc`, it MUST be read in FULL.


### Category: Bug / Useâ€‘Case Modification

Refer to the rule `dev_bug_use_case_modification.mdc`, it MUST be read in FULL.


### Category: Domain Rule Change

Refer to the rule `dev_domain_rule_change.mdc`, it MUST be read in FULL.


### Category: Internal Workflow / Refactor / Chore

Refer to the rule `dev_internal_workflow_refactor_chore.mdc`, it MUST be read in FULL.

---

### Validation and Commands (all Categories)

Before marking any task that **includes a commit** as `done`, run the following **sequentially** and receive human confirmation for the proposed commit:

- **Tests:** `npm test` (must pass).
- For `Red` tasks: validate expected failures.
- For `Plan Review`: validate analysis and tests as specified.
- Record results and commit confirmation/hash in `completedDetails`.

---

5.  **Mark Task as Done**

    - After work & validations pass **and** the commit (if any) is confirmed and performed, call `mcp_taskqueue_update_task` (`status='done'`) with full `completedDetails` (validation results, analysis, links, commit hash, etc.).

6.  **Await Human Confirmation & Approve Task**

    - Present the final task details (`mcp_taskqueue_read_task`), ask for explicit approval.
    - Record approval in `completedDetails`, then call `mcp_taskqueue_approve_task`.
    - **Commit Action:** Commits happen *inside* specific tasks after confirmation; approval seals the task.
    - **Finalize Trigger:** The project is finalized only after the **last task** is approved.

7.  **Repeat for Tasks** â€“ Return to **Step 2** (`get_next_task`) until all tasks in the project are complete.

8.  **Finalize Project** â€“ Call `mcp_taskqueue_finalize_project` when the project's final task is approved, then return to **Step 1** to pick the next open project.

---

## Reporting Current Status

- Determine current `projectId` and inâ€‘progress task (`mcp_taskqueue_read_task`). Present title, description, status, phase, and the project's `initialPrompt`. If nothing is in progress, state that and advise running **Step 2**.

## Task Creation Strategy

- **Starting a New Project**
    - **New Use Case:** Begin with `Acceptance Test â€“ Red` + `Plan Review #1`.
    - **Bug / Useâ€‘Case Modification:** Begin with `Plan Review #1`.
    - **Domain Rule Change:** Begin with `Impact Analysis` + `Global Verification & Close`.
    - **Internal Workflow / Refactor / Chore:** Begin with `Plan Review #1`.
- **Task Naming:** Follow naming conventions (`Component Batch #1 â€“ Red`, etc.); parent tasks in *Domain Rule Change* use descriptive titles (`Remove Obsolete Scenario: â€¦`).
- **Task Descriptions:** Clearly state goal, expected outcome, validation, and commitâ€‘confirmation steps.
- **Embed Category Reference:**
    - **When any task is created** (via `mcp_taskqueue_create_project` *or* `mcp_taskqueue_add_tasks_to_project`), the AI **MUST identify the project's category**.
    - Based on the category, the AI **MUST locate and read the corresponding workflow rule file**.
    - The AI **MUST include a reference** to this specific rule file at the beginning of the task description using the format `[rule_filename.mdc](mdc:.cursor/rules/rule_filename.mdc)`.
    - **Examples:**
        - For category "Domain Rule Change", reference `[dev_domain_rule_change.mdc](mdc:.cursor/rules/dev_domain_rule_change.mdc)`.
        - For category "Internal Workflow / Refactor / Chore", reference `[dev_internal_workflow_refactor_chore.mdc](mdc:.cursor/rules/dev_internal_workflow_refactor_chore.mdc)`.
        - For other categories (e.g., "New Use Case", "Bug / Useâ€‘Case Modification"), find and reference the relevant rule file following the naming convention `dev_<category_slug>.mdc` or similar.
    - After inserting the rule file reference, insert a horizontal rule (`---`).
    - Below that rule, it should be inserted all the references one by one, and insert another horizontal rule (`---`).
    - Below that rule, write the *taskâ€‘specific content* (title, context, acceptance criteria, validation commands, etc.).
- **Reference Gathering for New Tasks:**
    1. **Codeâ€‘base search:** Before adding any new task, run `codebase_search` and `grep_search` and `file_search` â€”repeat with varied queries if necessary, run all of themâ€” to locate existing files, tests, or implementations that match or closely resemble the requested work.
    2. **Similarity expansion:** If no direct match appears, broaden the search scope (different file types, neighbouring modules, semantic synonyms, etc.) and issue additional searches to surface *related* examples.
    3. **Web references:** When the codeâ€‘base truly contains no relevant material, perform `web_search` (multiple queries are recommended) and gather authoritative links that showcase a comparable pattern or solution.
    4. **Mandatory reference block:** The created task **must embed at least one reference** â€”preferably from the project itself; if unavailable, from the webâ€” immediately beneath the category reference and above the *task-specific content*.
    5. **Duplication guard:** If the searches reveal an existing or nearly identical solution, highlight this to the human developer to prevent duplicating functionality and to encourage reuse or refactor.
    6. **Task execution:** When later interpreting the task, the agent must consult *all* embedded references (READ EACH ONE of the files and FOLLOW EACH ONE the links) and then carry out the Categoryâ€‘specific instructions verbatim.
    - **Reference Formatting:**
        - **File References:** List relevant files using relative paths from the project root, formatted as markdown links: `[path/to/relevant/file.ext](path/to/relevant/file.ext)`.
        - **Web References:** List relevant URLs formatted as markdown links: `[Descriptive Title](https://example.com/relevant-page)`.
- **Preserving Embedded Reference on Updates:**
    - Whenever a task is modified through `mcp_taskqueue_update_task`, the embedded Category reference **must remain exactly as it was inserted**.
    - Whenever a task is modified through `mcp_taskqueue_update_task`, the referenced block **must remain exactly as it was inserted**.
    - Only the content *below* the separator (`---`) may be altered (e.g., clarifying the task, adding details). If new references are discussed (including files or urls), they MUST be added to the already existing references.
- **CRITICAL: Human Approval Required:** **NO** task may be created (via `mcp_taskqueue_create_project` or `mcp_taskqueue_add_tasks_to_project`) **without explicit human approval**. Before calling any of these functions, the proposed task content (including title, description, references, etc.) **MUST** be presented to the human developer for review. Proceed **ONLY** after receiving explicit confirmation. This approval step is mandatory and cannot be skipped under any circumstances.


## Task Status Management

  - **States:**
    - `not started`: Task has not been started.
    - `in progress`: Task is actively being worked on.
    - `done`: Task implementation is complete (requires `completedDetails`).
  - **Transitions:**
    - `not started` -> `in progress`
    - `in progress` -> `done` OR `not started`
    - `done` -> `in progress` (if rework is needed before approval)
  - **Approval:**
    - Tasks marked `done` require human review and confirmation.
    - The AI agent MUST ask the human for confirmation.
    - Once confirmation is received, the AI agent MUST record this confirmation within the task's `completedDetails` using `mcp_taskqueue_update_task`.
    - After recording confirmation, the AI agent uses `mcp_taskqueue_approve_task` to finalize approval.
    - Approved tasks cannot be modified.
    - Projects can only be finalized when all tasks are `done` and `approved`.